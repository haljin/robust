\chapter{Introduction}
What is Robust software? What does robustness mean? Those questions are seemingly simple to answer, however reality proves it is not so. Various specialists disagree upon the details of the definition.

\section{The definition of robustness}
However it is mostly agreed that robust software is software, that  is ,,hard to break'' or ,,bomb-proof''. That in turn means that the software is written in such a way, that it handles abnormal situations (incorrect inputs, bad function calls and many more) in a controlled manner, that is either by terminating in a controlled way or recovering from the unusual situation.~\cite{Bishop2003} The difference of opinions lie in the scope of the definition. For instance: Is a neat and tidy design also a measure of robustness?~\cite{Iovene2007} One could argue that it is as a neat design helps to prevent introduction of flaws, especially as the system is refined and developed further in time.  As such this could be an important consideration. Other aspects that are looked at are, for instance, good documentation and appropriate naming conventions~\cite{Iovene2007}, however these detract from what  is the core of the issue.

In principle, we can take the common elements of the definitions as our definition of robustness --- that is software that is resistant against abnormal situations, that can handle them appropriately and in a controlled way. This, of course, includes cases of controlled termination.

What is the difference between reliability and robustness however? We could consider that reliable software is software that allows access to its features constantly, with very little downtime. In other words, a reliable system provides service always whenever it is needed.~\cite{Wilson2009} That implies, that in case the system encounters abnormal situations, it should handle them as fast as possible and return to normal operation. This brings us seemingly close to the definition of robustness as mentioned above. One could argue that these two are the same and in fact, these definitions are often confused. However, looking closely, not every system that is considered robust, has to be accessible constantly --- there is no  mention of time and accessibility periods at all in the definitions! As such we could argue that all reliable systems are robust, but not all robust systems are reliable. This is further reinforced by definitions given here~\cite{Wilson2009}.  Why is that important though? Basically, we are able to take concept and techniques recommended for reliable software and apply them to our system, that has to be merely robust. 

\section{The significance of robustness}
Now that we have settled for  the definition we can think about its application. Why is robust software so important?

In an ideal world all code would be robust. It is an important quality in mission-critical systems, such as railways, airplanes control systems or automated heavy machinery, where an unhandled fault in the system could cause loss of lives. An error in a stock exchange program (that, for instance, automates transactions) could lead to massive losses for individuals and not only --- we have already noted occurrences of bots continuously running on the stock market to react to each other’s flaws and create market crashes, which can only get worse, as the presence of these bots increases. But it is not only these applications that need a robust approach. Nobody likes to write a several page-long essay in Microsoft Word, while forgetting to save the progress often, and then having it crash upon an attempt of resizing a picture. Although such an example is indirectly linked to the previous --- frustrated customers will not buy a faulty product, which will lead to loss of money for the company. As such faults usually mean trouble – not to mention that if we do it ,,right'' we get the bragging rights! ,,There is no way you can crash my program!'' we could exclaim.

Unfortunately reality then rears its ugly head and reminds us, that it is impossible to create a flawless system. No matter how hard we try, there will always be a way to crash all but the simplest systems. What we can do is try to minimize these ways as well as minimize the damage done. If a train system is programmed to always stop all trains in case of any failure, we err on the side of caution --- our passengers might be unnecessarily frustrated, but at least they will be alive!

To sum up: ensuring this particular quality in our software will lead to increased satisfaction of its users. Be it by preserving their health and safety, their money or simply their good mood!

\section{The aspects of robustness}
We know what to do, we know why should we do it, the question now is how?

When it comes to writing robust software our key mantra should be the famous quote ,,Trust No One''. Do not trust ourselves, that our code is indeed fault-free. Do not trust external developers, for they inadvertently made some mistakes in their libraries or even the operating system (if we are using its API).  Do not trust your users, that they will use your system in a sensible and correct way. Lastly, do not trust the universe itself --- there is no such thing as  a situation that will never happen, merely one that is unlikely.~\cite{Bishop2003}

These are the main highlights that we need to take into account during development. We need to protect ourselves against our own faults or those in the code we are referencing. We must also protect ourselves in every place where the user inputs anything into our system. The user may be plain stupid, but he may also be malicious --- SQL injections, XSRF and XSS attacks (against websites) can be performed and cause significant damage.

When reading the literature on the subject one term pops out multiple times and seems to be the best answer and solution to all the problems: defensive programming. Today’s languages feature many elements that are meant to make our lives in that regard easier. They abstract away from the ,,raw'' system helping us prevent such issues as memory corruption, loss of references and other, they contain mechanisms such as exception handling that ease the burden of handling multiple possible incorrect cases and many more.  Coupled with tools, such as SPEC\# that allow us for further defining the properties of the system it gives as a powerful toolbox with which to tackle problems mention in the previous section, by building figurative walls of try-catch blocks, pre- and post-conditions and others.

However is it the only approach? Hardly. While in imperative language with soft concurrency, such as Java or C\# (Soft concurrency, as in it is possible to create concurrent processes, it is only an addition rather than the main paradigm of the language – there is much in terms of shared state and memory which goes against the true concurrency model) it may be our best bet, there are languages and philosophies that decide to go against that rule and take a different approach.

Let us take an example of a different programming language – Erlang. Created by Ericsson for use in telecoms, this functional programming language has been made with one thing in mind – true no-shared-state concurrency – each Erlang system is dozens (or hundreds and even thousands) of processes that run in cooperation, however do not have access to shared resources – each process has its own data, that it could inform others about, however only it can directly read or write its own state. There are four main tenets of Erlang, that all programmers writing in that language should adhere to. The main one? Do not program defensively.~\cite{Armstrong2003} In Erlang, we let the processes crash, as this is not a problem – other processes are responsible for handling this event. This vastly different approach is also successful – Erlang boasts the highest rate of reliability achieved in software, with the famous Ericsson AXD301 telecom switch achieving nine ,,9''s reliability (99,9999999\%!).

\section{Our contribution}

Is the Erlang approach better or is the careful application of defensive programming a more certain solution? There is no simple answer to that question – even empirically we cannot prove one is better than other – systems written in both ways continue to operate mostly correctly, as well as both kinds suffer failures.

We intend to put the philosophies to the test and design a simple system, that will test various approaches as well as various tools to the test and see the results with our own eyes.  Comparison will be first and foremost done against the robustness of the solutions, however speed and ease of development should also be kept in consideration.
