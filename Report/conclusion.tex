\chapter{Comparison and conclusions}
Comparing the two approaches to programming is not straightforward as they are somewhat different, although we can find certain criteria by which we can compare the two. We have chosen some that we deem are most important for developers creating any system. 
\section{Speed and convenience of coding}
If the developer is accustomed with a programming language creating simple code (that is not devising any new complex algorithms) is always an easy and fast task. However, we found that since in Erlang there is no need for defensive programming, the entire process is done a bit faster. Adding all the possible clauses and catching exceptions in C\# program takes time and it is easy to omit something that we did not consider. At the same time in Erlang we care only about correct cases and inputs, simply deciding to crash on incorrect.

While in our example the C\# program does not do much in terms of catching exceptions, it does however specify contracts (which we do not want to catch as we want to be able to pinpoint where and why it occurred), which also take time to specify as they have to be though up beforehand and extra effort has to be made to ensure that the contracts are not only complete, but also correct.
\section{Testing tools}
Unit tests are the most commonly used test form in any larger project. However creating them by hand does not always ensure that all possible cases have been evaluated. In that regard Quickcheck, that generates randomized values from a pool of correct inputs does a much better job at covering all kinds of odd situations (as the generation is not simply blindly random, although it does not, in any way, depend on the tested code, just the generators themselves) and thanks to the excellent shrinking mechanisms and Erlang’s no-defensive-programming rule, pinpointing where the error exactly lies is relatively simple and we can test whole systems in that way, speeding up the process.

On the other hand, random generation does not always find the crashing case. Sometimes the crash is only found on a second or third run of Quickcheck test (alternatively the number of tests can be upped from the default 100). This means that even after running a billion tests we cannot be $100\%$ sure that the code is completely error-free. 

As such white-box code analysers such as Pex are the only definite answer. Only by generating tests based on knowing the actual tested code, can the testing really cover the entirety of the code. Unfortunately that is a very hard thing to do and we can see that Pex is still an experimental tool that is far from being perfect and cannot be applied to every situation
\section{Robustness}
Despite the presence of potential errors, which remain through testing, how robust is each of the solutions? On this field Erlang is a clear winner. Even though errors may still occur, Erlang/OTP’s in-built mechanisms ensure that the system is kept running with minimal downtime. Only severe errors lead to complete shutdown of the entire system, when a process would crash too often, which usually happens when there is a clear error, which we can easily eliminate through testing. In C\# on the other hand, if an unexpected exception occurs, that is it, the system goes down. Of course we could attempt to do a top-level catch-all but that is never a good idea, as we are unable to determine what state the system was in. In Erlang only single components would be restarted thus preserving the state of the rest of the system.
\section{Conclusions}
While Erlang might seem like a better tool at a glance it is imperative to understand that a good programmer always picks the tools (language) according to the task he is presented with. Erlang is an excellent tool for creating robust and reliable software, even though it requires changing the mindset from object-oriented (by far the most common nowadays) to process-oriented. However it is not the ultimate answer to all the questions (that, as we all know, is of course 42). Not all tasks can be compartmentalized in a distributed fashion. Over real distributed systems (made of up of several separate machines) other issues arise which also might mean Erlang is not as robust any more. Lastly, Erlang is not the most efficient tool to deal with tasks such as image processing or any OS related operations, save for the simplest. Therefore C\# and other similar languages should not be rejected, especially as the research into projects such as Pex may ultimately make the code written in those the most verifiable, ensuring maximum robustness.